<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Just-in-Time Compilation: The Next Big Thing?</title>

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
    <link rel="stylesheet" href="extensions/plugin/line-numbers/line-numbers.css">
    <link rel="stylesheet" href="extensions/css/highlight-styles/zenburn.css">
    <link rel="stylesheet" href="extensions/css/custom.css">

    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );

      function set_address(self, remote, local) {
        if (window.location.search.match("local")) {
          self.href = local;
        } else {
          self.href = remote;
        }
      }
    </script>

    <meta name="description" content="Just-in-Time Compilation: The Next Big Thing?">
    <meta name="author" content="Ben Deane & Kris Jusiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$">
          <script type="text/template">

#### CppCon / 16th September 2020

---

## Just-in-Time Compilation:
## The Next Big Thing?

---

#### Ben Deane & Kris Jusiak - [Quantlab Financial](https://www.quantlab.com/careers)

Note:
Introductions:

[Ben] This is Kris...

[Kris] This is Ben...

==============================================================================

### Agenda

* #### Motivation
<!-- .element: class="fragment" data-fragment-index="0" -->

* #### Existing solutions
<!-- .element: class="fragment" data-fragment-index="1" -->

* #### How it works*
<!-- .element: class="fragment" data-fragment-index="2" -->

* #### Examples: C++20 and beyond
<!-- .element: class="fragment" data-fragment-index="4" -->

* #### Summary / Future?
<!-- .element: class="fragment" data-fragment-index="5" -->

---

##### * Based on [P1609r1](https://wg21.link/p1609)
<!-- .element: class="fragment" data-fragment-index="2" -->

==============================================================================

## Motivation

----

### What is JITting?

* #### Instead of Ahead-of-Time (AOT), aka "the norm": It's like the application (/library) is the compiler...
<!-- .element: class="fragment" -->

* #### Just-in-Time (JIT) is compilation at the point of need
<!-- .element: class="fragment" -->

* #### It's like the application (/library) is the compiler...
<!-- .element: class="fragment" -->

Notes:
If you've seen JF's talk this is probably familiar

----

### Why JIT-compile?

* #### AOT is not possible
<!-- .element: class="fragment" -->

* #### AOT is not desirable
<!-- .element: class="fragment" -->

* #### JIT gives perf benefits
<!-- .element: class="fragment" -->

* #### JIT gives productivity benefits
<!-- .element: class="fragment" -->

* #### JIT allows different workflows/use cases
<!-- .element: class="fragment" -->

Notes:

----

### Sometimes AOT is not possible/desirable

* #### If I don't have the AOT source, obviously I can't compile it
<!-- .element: class="fragment" -->

* #### If I don't have the parameters that will constrain the code at runtime, I can't tailor the code to them
<!-- .element: class="fragment" -->

* #### AOT might lock me into an ABI
<!-- .element: class="fragment" -->

Notes:

If the source is provided by a client; by a colleague who is using my
library/application; by a tool that is autogenerating code, perhaps.

If I know arguments used to parameterize code, normally I could use a
template. But maybe these arguments are only available at runtime.

----

### Sometimes JIT gives performance benefits

* #### If I don't know where the source is going to be run, I can't AOT-compile with the best architecture flags
<!-- .element: class="fragment" -->

* #### I might not be running the code on just one architecture
<!-- .element: class="fragment" -->

* #### In order to get the best possible optimization, I need the best possible information about all of the code
<!-- .element: class="fragment" -->

Notes:

If I'm compiling for just one target, maybe I can achieve the best perf. But
many of us are not doing that. And many of us are shipping to multiple
architectures and maybe maintaining multiple binary distributions.

If we can reduce the amount of binary maintenance, that's probably good.

----

### Sometimes JIT is more productive

* #### I can trade AOT-compilation time (developer time) against JIT-compilation time (user time)
<!-- .element: class="fragment" -->

* #### With JIT, I can compile just what is needed rather than accounting for all possible use cases
<!-- .element: class="fragment" -->

Notes:

Compilation time is something we want to minimise. JIT allows a new tradeoff.
We're trying to minimise total time: compile-time + run-time. And that is going
to depend on several things.

With JIT we can minimise that total time *over time* by choosing when we compile
things as well as how we compile them.

And by compiling just what we need we can avoid unnecessary work.

----

### JIT allows different use cases

* #### "OK, so I can compile code at point of need. So what?"
<!-- .element: class="fragment" -->

* #### It's just the tip of the iceberg, as we shall see...
<!-- .element: class="fragment" -->

Notes:

Much of the second half of the talk covers various use cases that we've thought of.

There are bound to be many more. JIT is a sea-change in development, something
like adopting version control.

==============================================================================

## Existing solutions

----

### Existing solutions - C++

* #### [Cling](https://github.com/root-project/cling)
<!-- .element: class="fragment" data-fragment-index="0" -->

* #### [Runtime Compiled C++](https://github.com/RuntimeCompiledCPlusPlus) / [Easy-Jit](https://github.com/jmmartinez/easy-just-in-time)
<!-- .element: class="fragment" data-fragment-index="2" -->

* ### <font color="white">[[clang::jit]]</font> - [P1609r1](https://wg21.link/p1609)
<!-- .element: class="fragment" data-fragment-index="4" -->

* #### [D mixin](https://dlang.org/articles/mixin.html)**
<!-- .element: class="fragment" data-fragment-index="5" -->

* #### [Others](https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus/wiki/Alternatives)
<!-- .element: class="fragment" data-fragment-index="6" -->

---

##### * With custom modifications
<!-- .element: align="left" class="fragment" data-fragment-index="4" -->

##### ** Compile-time
<!-- .element: align="left" class="fragment" data-fragment-index="5" -->

----

#### [Cling](https://github.com/root-project/cling)

#### * Primary a Read‚Äìeval‚Äìprint loop (REPL)
<!-- .element: align="left" class="fragment" data-fragment-index="1" -->

#### * Always JIT compiles the whole program
<!-- .element: align="left" class="fragment" data-fragment-index="2" -->

#### * Minimal optimizations
<!-- .element: align="left" class="fragment" data-fragment-index="3" -->

---

#### [\[\[clang::jit\]\]](https://github.com/hfinkel/llvm-project-cxxjit)

#### * C++ language extension (Attribute)
<!-- .element: align="left" class="fragment" data-fragment-index="1" -->

#### * Allows JIT compilation of specifically-annotated functions (Memoization)
<!-- .element: align="left" class="fragment" data-fragment-index="2" -->

#### * Maximal optimizations not even possible at build time
<!-- .element: align="left" class="fragment" data-fragment-index="3" -->

----

### D mixin - Compile-time JIT

```d
template GenStruct(string Name, string M1) {
  const char[] GenStruct = "struct " ~ Name ~ "{ int " ~ M1 ~ "; }";
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

<pre><code>mixin(GenStruct!("Foo", "bar")); // 'JITting' at Compile-time</code> -> <font color="darkgray">struct Foo { int bar; }</font></pre>
<!-- .element: class="fragment" data-fragment-index="2" -->

#### https://dlang.org/articles/mixin.html
<!-- .element: class="fragment" data-fragment-index="3" -->

==============================================================================

## How it works

----

### Hello World - [P1609r1](https://wg21.link/p1609)

```cpp
template <class T>
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
// Instantiation at Run-time Point-Of-Instantiation (POI)
// CXXFLAGS comes from the host compilation (might be overwritten)
```
<!-- .element: class="fragment" data-fragment-index="6" -->

```cpp
[[clang::jit]] // It requires `-fjit` compilation flag
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
auto jit() -> void {
  std::cout << typeid(T).name() << '\n';
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

<pre><code>jit<‚Äãint>()   // Type</code> -> <font color="lime">i</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code>jit<‚Äã"int">() // Type/String</code> -> <font color="lime">i</font></pre>
<!-- .element: class="fragment" data-fragment-index="5" -->

----

### Hello World - [P1609r1](https://wg21.link/p1609)

###### hello_world.cpp
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
int main(int argc, const char** argv) {
  jit<argv[1]>();
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
$CXX $CXXFLAGS -fjit hello_world.cpp -o hello_world
```
<!-- .element: class="fragment" data-fragment-index="2" -->

<pre><code>ls -lh hello_world</code> -> <font color="white">75M</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

##### Compiler and the pre-compiled module of the host are included in the binary
<!-- .element: class="fragment" data-fragment-index="4" -->

----

### Hello World - [P1609r1](https://wg21.link/p1609)

<pre><code>./hello_world "int"</code> -> <font color="lime">i</font></pre>
<!-- .element: class="fragment" data-fragment-index="1" -->

<pre><code>./hello_world "double"</code> -> <font color="lime">d</font></pre>
<!-- .element: class="fragment" data-fragment-index="2" -->

<pre><code>./hello_world "decltype([]{})"</code> -> <font color="lime">3$_0</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code>./hello_world "error"</code> -> <font color="salmon">terminate called after throwing an instance of
    'compilation_error'</font></pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

----

### Hello World - [P1609r1](https://wg21.link/p1609)

```cpp
template <class T>
[[clang::jit]] auto jit() -> void {
  T{}(); // Invokes the lambda expression
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

<pre><code>./hello_world "decltype([]{
                 std::puts(\"Hello world from JIT!\");
              })"</code> -> <font color="lime">Hello world from JIT!</font></pre>
<!-- .element: class="fragment" data-fragment-index="2" -->

---

```cpp
template <auto Expr> // Non-Type Template Parameter (NTTP)
[[clang::jit]] auto jit() -> void {
  Expr();
}
```
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code>./hello_world "[]{ std::puts(\"Hello world from JIT!\"); }"</code> -> <font color="lime">Hello world from JIT!</font></pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

----

### Handling errors

```cpp
template <auto Expr>
[[clang::jit]] auto jit() -> void {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  try {
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    Expr(); // It potentially throws a `compilation_error`
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  } catch(const compilation_error& error) {
    std::cerr << error.what() << '\n';
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

<pre><code>jit<"foo">() // Assuming that the host doesn't define 'foo'</code> -> <font color="salmon">error: 'foo' was not declared in this scope</font></pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

----

### Questions?

----

### Utilities / compiles

```cpp
template <auto Expr>
[[clang::jit]] auto jit_compiles() ->
  std::expected<bool, compilation_error> {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  try {
    jit<Expr>();
  } catch(const compilation_error& error) {
    return error;
  }

  return true;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

<pre><code>assert(jit_compiles<"[]{}">())</code> -> <font color="lime">üëç</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code>assert(jit_compiles<"[}">())</code> -> <font color="salmon">Assertion `compiles<"[}">()' failed</font></pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

----

### Utilities / Assert

```cpp
template <auto TExpr>
[[clang::jit]] auto jit_assert() -> void {
  static_assert(TExpr()); // Notice it's a static_assert
}
```
<!-- .element: class="fragment" data-fragment-index="5" -->

---

<pre><code>jit_assert<"[]{ return 42 == 42; }">()</code> -> <font color="lime">üëç</font></pre>
<!-- .element: class="fragment" data-fragment-index="6" -->

<pre><code>jit_assert<"[]{ return 43 == 42; }">()</code> -> <font color="salmon">error: static assertion failed</font></pre>
<!-- .element: class="fragment" data-fragment-index="7" -->

----

### Read‚Äìeval‚Äìprint loop (REPL)

```cpp
using meta = std::string; // [Future] Abstract Syntax Tree (AST) node
```
<!-- .element: class="fragment" data-fragment-index="1" -->

##### [P1717: Compile¬≠time Metaprogramming in C++](https://wg21.link/p1717)
<!-- .element: class="fragment" data-fragment-index="2" -->

---

```cpp
std::vector<meta> v{};
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
v.push_back("int");
v.push_back("double");
```
<!-- .element: class="fragment" data-fragment-index="4" -->

---

```cpp
template<std::input_iterator InputIterator>
[[nodiscard]] auto join(InputIterator first, InputIterator last,
                        auto&& f, const auto separator);
```
<!-- .element: class="fragment" data-fragment-index="5" -->

```cpp
jit_assert<"[]{ return std::is_same_v<std::tuple<int, double>,"s +
  "std::tuple<" + join(v, [](const auto& e) { return e; }), ',') +
">>; }">()
```
<!-- .element: class="fragment" data-fragment-index="6" -->

##### JITting allows to manipulate `meta` types using 'normal' C++
<!-- .element: class="fragment" data-fragment-index="6" -->

----

### CPP Injection / Security breach

<img src="images/sql_injection.png" style="width: 40%; background:none; border:none; box-shadow:none;" />
<!-- .element: class="fragment" -->

```sql
SELECT * FROM Users WHERE Name='' or 1==1--' and Password=''
```
<!-- .element: class="fragment" -->

---

##### CPP Injection
<!-- .element: class="fragment" -->

```cpp
int main() {
  jit<"[]{ std::cout << \""s + std::getenv("USER") + "\"; }">();
}
```
<!-- .element: class="fragment" -->

<pre><code>USER=John ./cpp_injection</code> -> <font color="lime">John</font></pre>
<!-- .element: class="fragment" -->

<pre><code>USER="\";std::system(\"rm -rf /\");\"" ./cpp_injection</code> // <font color="darkgray">[]{ std::cout << "";std::system("rm -rf /");""; }</font><br/> -> <font color="lime">üîì</font></pre>
<!-- .element: class="fragment"-->

----

### How it works? - Details

<a href="https://www.youtube.com/watch?v=6dv9vdGIaWs"><img src="images/jit.png" style="width: 75%; background:none; border:none; box-shadow:none;" /></a>

#### https://github.com/hfinkel/llvm-project-cxxjit

==============================================================================

## Examples: C++20 and beyond

----

### C++ as a scripting language

```cpp
int main(int argc, const char** argv) {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  const auto file_contents = [&] {
    std::ifstream f{argv[1]};
    f.ignore(std::numeric_limits<std::streamsize>::max(),
             f.widen('\n'));
    return std::string{std::istreambuf_iterator<char>{f},
                       std::istreambuf_iterator<char>{}};
  }();
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  jit<"[]{" + file_contents + '}'>();
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```bash
#!/usr/bin/c++-jit
std::cout << "Hello, world!\n";
```
<!-- .element: class="fragment" -->

<pre><code>./hello.cpps</code> -> <font color="lime">Hello, world!</font></pre>
<!-- .element: class="fragment" -->

Notes:

We have the issue of what to do about includes of course.
We can't include things inside a lambda expression.
Modules to the rescue?

----

### Mix compile-time & run-time

```cpp
template <auto... Ns> auto sort(auto... ns) -> std::string {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  std::vector v{Ns..., ns...};
  std::sort(std::begin(v), std::end(v));
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  return "std::array{" +
    join([](const auto& e) { return std::to_string(e); }, ',') +
  '}';
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
jit_assert<"[]{ return " +
  sort<1, 9, 3>(4, 2, 7) + " == std::array{1, 2, 3, 4, 7, 9}; }";
>()
```
<!-- .element: class="fragment" data-fragment-index="4" -->

Notes:

Here is a sort function that takes some of its parameters as NTTPs, and the rest
as runtime values.

We're using a `vector` here but we could also use an `array` of `T`s with
`sizeof...` on both parameter packs.

Or the runtime argument could be an `array` or `vector` of values perhaps.

The return value is a `string` that we'll use as a parameter for a JIT function.

Here is the JIT function template. We pass in the result of `sort` i.e. the
comma-separated string of sorted values.

Note that `sort` doesn't have to be `constexpr`!

----

### JIT - Use case

```cpp
int main() {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  while (there is an input...) { // REPL - user
                                 // External data - file/tcp/udp/...
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
   process input data...
   collect input data... // For the future processing...
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
   if (an explicit trigger or
       collected data provides benefits) { // Artificial Intelligence?
     jit<"based on collected data">()
     [Optional] Save an optimized library/binary
   }
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

###### It promotes Run-time data to Compile-time data / Optimized library/binary can be saved for free (already compiled)
<!-- .element: class="fragment" data-fragment-index="4" -->

----

### Compile-time dispatch

```cpp
// Handlers
struct foo { static auto on(const auto& event){ std::puts("foo"); } };
struct bar { static auto on(const auto& event){ std::puts("bar"); } };
```
<!-- .element: class="fragment"-->

```cpp
// Events
struct e1 {};
struct e2 {};
struct e3 {};
```
<!-- .element: class="fragment"-->

---

```cpp
// Mappings - Can be extended at Run-time
std::unordered_map mappings = {
  std::pair{ "e1", "foo" },
  std::pair{ "e2", "bar" }
};
```
<!-- .element: class="fragment"-->

----

### Compile-time dispatch

```cpp
constexpr auto make_dispatcher(const auto& mappings) {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  return "boost::mp11::mp_list<" +
    join(mappings, [](const auto& mapping) {
      const auto& [ event, handler ] = mapping;
      return "std::pair<" + event + ',' + handler + '>';
    }, ',') +
  '>';
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
template <class TDispatcher, class TEvent>
[[clang::jit]] auto dispatch(const TEvent& event) -> void {
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  boost::mp11::mp_map_find<TDispatcher, TEvent>::on(event);
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="3" -->

###### [mp_map_find](https://www.boost.org/doc/libs/1_66_0/libs/mp11/doc/html/mp11.html#mp_map_find_m_k) - returns a handler for a given event or void otherwise
<!-- .element: class="fragment" data-fragment-index="4" -->

----

### Compile-time dispatch

<pre><code>dispatch<‚Äãmake_dispatcher(mappings)>(e1{})</code> -> <font color="lime">foo</font></pre>
<!-- .element: class="fragment" -->

<img src="images/asm_dispatch.png" style="width: 35%; background:none; border:none; box-shadow:none;" />
<!-- .element: class="fragment" -->

<pre><code>dispatch<‚Äãmake_dispatcher(mappings)>(e2{})</code> -> <font color="lime">bar</font></pre>
<!-- .element: class="fragment" -->

----

### Compile-time dispatch

<pre><code>dispatch<‚Äãmake_dispatcher(mappings)>(e3{})</code> // <font color="darkgray">Run-time compilation error</font><br/> -> <font color="salmon">error: type 'mp_map_find<
                   boost::mp11::mp_list<
                     std::pair<‚Äãe1, foo>,
                     std::pair<‚Äãe2, bar>
                   >,
                   e3
                 >' (aka 'void')
    cannot be used prior to '::' because it has no members</font></pre>
<!-- .element: class="fragment" -->

<pre><code>dispatch<‚Äãmake_dispatcher(mappings)>(e4{})</code> // <font color="darkgray">Compilation error</font><br/> -> <font color="salmon">error: use of undeclared identifier 'e4'</font></pre>
<!-- .element: class="fragment" -->

----

### Run-time dispatch

```cpp
// Events with Run-time ids
struct e1 { static constexpr auto id = 1; };
struct e2 { static constexpr auto id = 2; };
struct e3 { static constexpr auto id = 3; };
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
constexpr auto make_dispatcher(const auto& mappings) {
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  return R"([](int id) {
    switch(id) { default: assert(false); break;)" +
      join(mappings, [](const auto& mapping) {
        const auto& [ event, handler ] = mapping;
        return "case " + event + "::id:" + handler +
          "::on(" + event + "{}); break;";
      }) +
    '}' +
  '}';
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="2" -->

###### [[likely]] / [[unlikely]] attributes can be used / Based on the Run-time data
<!-- .element: class="fragment" data-fragment-index="3" -->
----

### Run-time dispatch

```cpp
template <auto Dispatch>
[[clang::jit]] auto dispatch(int id) -> void {
  Dispatch(id);
}
```
<!-- .element: class="fragment" data-fragment-index="3" -->

---

<pre><code>dispatch<‚Äãmake_dispatcher(mappings)>(1)</code> -> <font color="lime">foo</font></pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

<pre><code>dispatch<‚Äãmake_dispatcher(mappings)>(2)</code> -> <font color="lime">bar</font></pre>
<!-- .element: class="fragment" data-fragment-index="5" -->

<pre><code>dispatch<‚Äãmake_dispatcher(mappings)>(0)</code> -> <font color="salmon">Assertion `false' failed</font> // Default case</pre>
<!-- .element: class="fragment" data-fragment-index="6" -->

----

### Save library/binary

```cpp
template <auto Dispatch>
[[clang::jit(R"(CXXFLAGS="-O3 -DNDEBUG", out="dispatch.ir*")")]
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
auto dispatch(int id) -> void { // -> _Z3dispatchi
  Dispatch(id);
}
```
<!-- .element: class="fragment" data-fragment-index="2" -->

---

<pre><code>dispatch<‚Äãmake_dispatcher(mappings)>(1)</code> // Runs dispatch and produces dispatch.ir*</font><br/> -> <font color="lime">foo</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code>void(&dispatch<‚Äãmake_dispatcher(mappings)>)</code> // Produces dispatch.ir* without running dispatch</font></pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

##### * Intermediate representation (IR)
<!-- .element: class="fragment" data-fragment-index="1" -->

----

### Save library/binary

###### main.cpp
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
#include <string>   // std::stoi
void dispatch(int); // _Z3dispatchi - Mangled symbol with no templates
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
int main(int argc, const char** argv) {
  dispatch(std::stoi(argv[1]));
}
```
<!-- .element: class="fragment" data-fragment-index="2" -->

---

```sh
$LLC -filetype=obj dispatch.ir -o dispatch.o # IR to an object file
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```sh
$CXX $CXXFLAGS dispatch.o main.cpp -o dispatch # No `-fjit` required
```
<!-- .element: class="fragment" data-fragment-index="4" -->

<pre><code>ls -lh dispatch</code> -> <font color="white">1.1M # Compiler is not included</font></pre>
<!-- .element: class="fragment" data-fragment-index="5" -->

<pre><code>nm dispatch | grep dispatch # List symbols from object files</code> -> <font color="white">_Z3dispatchi</font></pre>
<!-- .element: class="fragment" data-fragment-index="6" -->

##### LLC - [LLVM static compiler](https://llvm.org/docs/CommandGuide/llc.html)
<!-- .element: class="fragment" data-fragment-index="3" -->

----

### Save library/binary

<pre><code>./dispatch 1</code> -> <font color="lime">foo</font></pre>
<!-- .element: class="fragment" -->

<pre><code>./dispatch 2</code> -> <font color="lime">bar</font></pre>
<!-- .element: class="fragment" -->

<pre><code>./dispatch 0</code> -> <font color="darkgray"># If NDEBUG is defined then assert does nothing</font> // Default case</pre>
<!-- .element: class="fragment" -->

<img src="images/asm_binary.png" style="width: 35%; background:none; border:none; box-shadow:none;" />
<!-- .element: class="fragment" -->

----

### Questions?

----

### JIT & concepts

```cpp
template <class TIO>
concept readable_io =
  requires(TIO& io, std::byte* buffer, std::size_t size) {
    { io.read(buffer, size) } -> std::same_as<std::size_t>;
  };
```
<!-- .element: class="fragment" -->

---

```cpp
struct my_readable_io {
  auto read(std::byte* buffer, std::size_t size) -> std::size_t;
};
```
<!-- .element: class="fragment" -->

```cpp
struct my_illiterate_io {
  auto read() -> void;
};
```
<!-- .element: class="fragment" -->

Notes:

Here we have a concept. Not a very good concept, but a concept nevertheless.
(Explain concept)

And here we have a type that satisfies the concept.

We can use JIT to check that the type satisfies the concept.

----

### JIT & concepts

<pre><code>jit_assert<"[]{ return readable_io<‚Äãmy_readable_io>; }">()</code> -> <font color="lime">üëç</font></pre>
<!-- .element: class="fragment" -->

<pre><code>jit_assert<"[]{ return readable_io<‚Äãmy_illiterate_io>; }">()</code> -> <font color="salmon">error: static assertion failed<br/>    constraints not satisfied</font></pre>
<!-- .element: class="fragment" -->

Notes:

We can check the concept at the point where we "load" the user code, without
incurring the full cost of compilation, and we can give them a nice error.

Of course the question remains: how to produce a well-formed string to jit? The
strings we have here are hardcoded: if the io type is given to us as "C++ text"
from the user, what are we going to do with it?

This code assumes we know the name of the struct, which we will have to somehow
figure out if this is user code passed to us at runtime.

----

### User code

```cpp
// onerous?
decltype([]{
  struct user_io_type {
    auto read(std::byte* buffer, std::size_t size) -> std::size_t {
      // user code here
    }
  };
  return user_io_type{};
}())
```
<!-- .element: class="fragment" -->

```cpp
// desired?
struct user_io_type {
  auto read(std::byte* buffer, std::size_t size) -> std::size_t {
    // user code here
  }
};
```
<!-- .element: class="fragment" -->

Notes:

One way to do that is to wrap the type inside a lambda expression.

We've seen this already in the talk, it's using the new C++20 feature of lambdas
in unevaluated contexts.

GCC 10.2 error with struct in lambda in decltype?

It's a bit onerous for the user to have to wrap everything in a lambda
expression? We would like them to be able to supply types.

----

### Easier user code

```cpp
struct user_io_type {
  auto read(std::byte* buffer, std::size_t size) -> std::size_t {
    // user code here
  }
};
```
<!-- .element: class="fragment" -->

```cpp
jit_assert<"[]{ return readable_io<decltype("s +
                "[]{ using T = " + user_code +
                "; return T{}; }())>; }">()
```
<!-- .element: class="fragment" -->

Notes:

We can wrap the user code in a lambda ourselves using a judicious `using`
declaration.

Because we are wrapping this in a lambda though, it's going to have some
limitations on user code and what users can do.

----

### User code limitations

```cpp
// all of this is going inside a lambda
```
<!-- .element: class="fragment" data-fragment-index="0" -->

``` cpp
#include <3rd_party_library.h> // how?
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
struct user_io_type {
```
<!-- .element: class="fragment" data-fragment-index="0" -->

```cpp
  auto a_function_template(auto arg) {
    // error: templates cannot be declared inside of a local class
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  auto a_function() {
    return [] (auto arg) {
      // this is a sneaky function template!
    };
  }
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
};
```
<!-- .element: class="fragment" data-fragment-index="0" -->

Notes:

Ultimately all user code is going into some evaluation context, where at the
moment we can't have #include directives.

We also have a limitation that local classes can't have templates inside them.
And this is annoying to users: it looks like they're writing "normal" code, but
there are a few hidden limitations.

Of course, local classes CAN have templates because they can have generic
lambdas. But they can't have "regular code" in there. So this is a workaround
for that issue, but one that complicates both the JITted user code and the
calling machinery of the host.

----

### Working around limitations

* #### Precompiled headers
<!-- .element: class="fragment" -->

* #### Precompiled modules
<!-- .element: class="fragment" -->

* #### [Future] AST injection (meta/reflection)?
<!-- .element: class="fragment" -->

* #### [Nearer future?] Templates in local classes
<!-- .element: class="fragment" -->

  * #### [P1988 Allow Templates in Local Classes](https://wg21.link/p1988)
  <!-- .element: class="fragment" -->

  * #### [P2044 Member Templates for Local Classes](https://wg21.link/p2044)
  <!-- .element: class="fragment" -->

Notes:

The user can control compilation, so they can specify precompiled fragments to
the compiler - either headers or modules. And this is some sort of workaround.
Maybe in future we'll have a better one.

More likely sooner we'll get templates inside local classes, because we already
have them with generic lambdas.

P1988 by Steve Downey

P2044 by Robert Leahy

----

### JITting mods

* #### (+) Performance vs scripting language
<!-- .element: class="fragment" -->

* #### (+) Versioning is easier
<!-- .element: class="fragment" -->

* #### (+) Sandboxing with the type system
<!-- .element: class="fragment" -->

Notes:

Perf vs other mod styles: e.g. scripting language.

Versioning is enforced trivially by the compiler: if it compiles, it's OK.
Compare manual versioning or DLL versioning with ABI issues.

Use phantom types/tags to identify user code. Use the type system for safety.

----

### Sandboxing user code

```cpp
enum struct PrivilegeLevel { USER, DEVELOPER };
```
<!-- .element: class="fragment" -->

```cpp
template <class T, auto P>
struct readable_io_wrapper : T {
  constexpr auto privilege_level = P;
};
```
<!-- .element: class="fragment" -->

```cpp
template <class TUserIO>
[[clang::jit]] auto jit_user_readable_io() {
  return readable_io_wrapper<TUserIO, PrivilegeLevel::USER>{};
}
```
<!-- .element: class="fragment" -->

```cpp
template <class T>
concept privileged = T::privilege_level == PrivilegeLevel::DEVELOPER;

template <privileged TIO>
auto do_privileged_operation(TIO &io) { ... }
```
<!-- .element: class="fragment" -->

Notes:

Here we show how to mark a user-injected class with the appropriate
privilege level.

How to prevent user code from calling into privileged code? Inject dependencies
to provide the API for users.

In general it's hard to prevent this entirely though... ultimately user code is
C++ so can circumvent most protection mechanisms you put in. You can do various
things to make it harder, but the goal here is to provide a nice API & JIT-time
errors rather than to completely protect.

----

### JITting user code? Why not JIT dev code?

* #### Breaking down the walls of the compiler & linker
<!-- .element: class="fragment" -->

  * #### (+) Incremental compilation on a running system
  <!-- .element: class="fragment" -->

  * #### (+) Patching with source code
  <!-- .element: class="fragment" -->

  * #### (+) Programming with concepts: platform team vs application team
  <!-- .element: class="fragment" -->

Notes:

==============================================================================

## Summary / Future?

----

### [\[\[clang::jit\]\]](https://github.com/hfinkel/llvm-project-cxxjit) - Costs & Benefits

#### (+) Run-time performance (Optimizations based on run-time data/available hardware)
<!-- .element: align="left" class="fragment" data-fragment-index="1" -->

#### (+) Compile-time performance (Memoization)
<!-- .element: align="left" class="fragment" data-fragment-index="2" -->

#### (+) Direct access to the host / STL algorithms for MetaProgramming with types
<!-- .element: align="left" class="fragment" data-fragment-index="3" -->

---

#### (-) Based on strings (security concerns)
<!-- .element: align="left" class="fragment" data-fragment-index="1" -->

#### (-) Doesn't support compile-time injection
<!-- .element: align="left" class="fragment" data-fragment-index="2" -->

----

### Future? / Compile-time & Run-time

<pre><code>template <‚Äãclass T>
auto future(); // No attribute at the declaration side</code> // <font color="darkgray">Run-time</font><br/> -> <font color="white">auto jit = "int"s;
    [[jit]] future<‚Äãjit>()</font> // Attribute at the calling side</pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code>template <‚Äãclass T>
constexpr auto future();</code> // <font color="darkgray">Run/Compile-time</font><br/> -> <font color="white">auto jit = "int"s;
    [[jit]] future<‚Äãjit>()</font><br/>    <font color="white">[[jit]] future<"int">()</font></pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

<pre><code>template <‚Äãclass T>
consteval auto future();</code> // <font color="darkgray">Compile-time</font><br/> -> <font color="white">[[jit]] future<"int">()</font></pre>
<!-- .element: class="fragment" data-fragment-index="5" -->

---

```cpp
 -> future<int>() // Valid in all cases
```
<!-- .element: class="fragment" data-fragment-index="6" -->

----

### Future? / Meta - Stringless Solution

```cpp
auto i = 42; // Run-time value
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
using type = reify(meta<std::integral_constant>(i)); // AST node
```
<!-- .element: class="fragment" data-fragment-index="2" -->

<pre><code>future<‚Äãtype>() // No attribute required</code> // <font color="darkgray">future<‚Äãstd::integral_constant<42>>()</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

---

##### To "reify" something is to take something that is abstract and regard it as material
<!-- .element: class="fragment" data-fragment-index="2" -->

---

##### [P1717: Compile¬≠time Metaprogramming in C++](https://wg21.link/p1717)
<!-- .element: class="fragment" data-fragment-index="2" -->

==============================================================================

<a href="https://www.quantlab.com"><img src="images/quantlab-logo.svg" style="width: 35%; background:none; border:none; box-shadow:none;" /></a>

---

### Let's `JIT` all the things?!

#### Questions? / [#sig_jit](https://cppcon.slack.com/archives/C01AE7CF1FWa)

---

#### https://github.com/QuantlabFinancial | https://www.quantlab.com/careers

==============================================================================

## Bonus slides

----

### JIT in the compiler - Speculation

> Compilation is ~becoming~ quite complicated
<!-- .element: class="fragment" -->

##### [P0992: Translation and Evaluation](https://wg21.link/p0992)
<!-- .element: class="fragment" -->

Notes:

Compilation is fast becoming a monolithic pattern that mixes translation with
evaluation. In order to instantiate X, you need to evaluate Y, which mean you
need to instantiate Z, etc. Regular SFINAE, expression SFINAE, concepts, etc,
etc, etc.

Andrew Sutton wrote a paper in which he put forward a model for compilation that
separates translation from evaluation. This is very much a mental model that a
JIT workflow supports. And it can be recursive.

----

### JIT in the compiler

* #### Data promotion from compile-time to runtime?
<!-- .element: class="fragment" -->

* #### Compilation time variability?
<!-- .element: class="fragment" -->

* #### Cross compilation?
<!-- .element: class="fragment" -->

Notes:
Easier compiler development/extension? (Moddable compiler)
          </script>
        </section>

      </div>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Display controls in the bottom right corner
        controls: false,

        // Display a presentation progress bar
        progress: false,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'convex', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'extensions/plugin/line-numbers/line-numbers.js' }
        ]
      });
    </script>

