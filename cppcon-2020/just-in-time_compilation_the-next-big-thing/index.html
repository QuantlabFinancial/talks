<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Just-in-Time Compilation: The Next Big Thing?</title>

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
    <link rel="stylesheet" href="extensions/plugin/line-numbers/line-numbers.css">
    <link rel="stylesheet" href="extensions/css/highlight-styles/zenburn.css">
    <link rel="stylesheet" href="extensions/css/custom.css">

    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );

      function set_address(self, remote, local) {
        if (window.location.search.match("local")) {
          self.href = local;
        } else {
          self.href = remote;
        }
      }
    </script>

    <meta name="description" content="Just-in-Time Compilation: The Next Big Thing?">
    <meta name="author" content="Ben Deane & Kris Jusiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$">
          <script type="text/template">

#### CppCon / 16th September 2020

---

## Just-in-Time Compilation: The Next Big Thing?

---

#### Ben Deane & Kris Jusiak - [Quantlab Financial](https://www.quantlab.com/careers)

Note:
Introductions:

[Ben] This is Kris...

[Kris] This is Ben...

==============================================================================

### Agenda

* #### Motivation
<!-- .element: class="fragment" data-fragment-index="0" -->

* #### Existing solutions
<!-- .element: class="fragment" data-fragment-index="1" -->

* #### How it works*
<!-- .element: class="fragment" data-fragment-index="2" -->

  * #### Simple use cases
<!-- .element: class="fragment" data-fragment-index="3" -->

* #### Examples: C++20 and beyond
<!-- .element: class="fragment" data-fragment-index="4" -->

* #### Summary
<!-- .element: class="fragment" data-fragment-index="5" -->

---

##### * Based on [P1609r1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1609r3.html)
<!-- .element: class="fragment" data-fragment-index="2" -->

==============================================================================

## Motivation

----

### What is JITting?

Instead of Ahead-of-Time (AOT), aka "the norm":

Just-in-Time (JIT) is compilation at the point of need.

It's like the application (/library) is the compiler...

Notes:
If you've seen JF's talk this is probably familiar

----

### Why JIT-compile?

One or more of these reasons:

* AOT is not possible
* AOT is not desirable
* JIT gives perf benefits
* JIT gives productivity benefits
* JIT allows different workflows/use cases

Notes:

----

### Sometimes AOT is not possible/desirable

* If I don't *have* the AOT source, obviously I can't compile it.
* If I don't *have* the parameters that will constrain the code at runtime, I can't tailor the code to them.
* AOT might lock me into an ABI.

Notes:

If the source is provided by a client; by a colleague who is using my
library/application; by a tool that is autogenerating code, perhaps.

If I know arguments used to parameterize code, normally I could use a
template. But maybe these arguments are only available at runtime.

----

### Sometimes JIT gives performance benefits

* If I don't know where the source is going to be run, I can't AOT-compile with the best architecture flags.
* I might not be running the code on just one architecture.
* In order to get the best possible optimization, I need the best possible information about *all* the code.

Notes:

If I'm compiling for just one target, maybe I can achieve the best perf. But
many of us are not doing that. And many of us are shipping to multiple
architectures and maybe maintaining multiple binary distributions.

If we can reduce the amount of binary maintenance, that's probably good.

----

### Sometimes JIT is more productive

* I can trade AOT-compilation time (developer time) against JIT-compilation time (user time).
* With JIT, I can compile just what is needed rather than accounting for all possible use cases.

Notes:

Compilation time is something we want to minimise. JIT allows a new tradeoff.
We're trying to minimise total time: compile-time + run-time. And that is going
to depend on several things.

With JIT we can minimise that total time *over time* by choosing when we compile
things as well as how we compile them.

And by compiling just what we need we can avoid unnecessary work.

----

### JIT allows different use cases

* "OK, so I can compile code at point of need. So what?"
* It's just the tip of the iceberg, as we shall see...

Notes:

Much of the second half of the talk covers various use cases that we've thought of.

There are bound to be many more. JIT is a sea-change in development, something
like adopting version control.

==============================================================================

## Existing solutions

----

### Existing solutions

* #### [Cling](https://github.com/root-project/cling)
<!-- .element: class="fragment" data-fragment-index="0" -->

* #### [Runtime Compiled C++](https://github.com/RuntimeCompiledCPlusPlus) / [Easy-Jit](https://github.com/jmmartinez/easy-just-in-time)
<!-- .element: class="fragment" data-fragment-index="2" -->

* #### <ins>[[clang::jit]] - [P1609r1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1609r3.html)</ins>*
<!-- .element: class="fragment" data-fragment-index="4" -->

* #### [D mixin](https://dlang.org/articles/mixin.html)**
<!-- .element: class="fragment" data-fragment-index="5" -->

* #### [Others](https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus/wiki/Alternatives)
<!-- .element: class="fragment" data-fragment-index="6" -->

---

##### * With custom modifications
<!-- .element: class="fragment" data-fragment-index="4" -->

##### ** Compile-time
<!-- .element: class="fragment" data-fragment-index="5" -->

----

### Cling vs [[clang::jit]]

* `Cling` is primarily a Read–eval–print loop (REPL) and always JIT compiles the whole program with minimal optimization
<!-- .element: class="fragment" -->

* `[[clang::jit]]` is a C++ language extension to allow JIT compilation of specifically-annotated functions with user-supplied run-time constants for maximal optimizations not even possible at build time
<!-- .element: class="fragment" -->

----

### D mixin - Compile-time JIT

```d
template GenStruct(string Name, string M1) {
  const char[] GenStruct = "struct " ~ Name ~ "{ int " ~ M1 ~ "; }";
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```d
mixin(GenStruct!("Foo", "bar")); // [[clang::jit]] at compile-time
```
<!-- .element: class="fragment" data-fragment-index="2" -->

---

```d
struct Foo { int bar; }
```
<!-- .element: class="fragment" data-fragment-index="3" -->

#### https://dlang.org/articles/mixin.html
<!-- .element: class="fragment" data-fragment-index="4" -->

==============================================================================

## How it works

----

### Hello World - [P1609r1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1609r3.html)

```cpp
template <class T>
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
[[clang::jit]] // instantiation at run-time
               // Point-Of-Instantiation (POI)
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
auto jit() -> void {
  std::cout << typeid(T).name() << '\n';
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

<pre><code>jit< int >()   // type</code> -> <font color="lime">i</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code>jit< "int" >() // string/type</code> -> <font color="lime">i</font></pre>
<!-- .element: class="fragment" data-fragment-index="5" -->

----

### Hello World - [P1609r1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1609r3.html)

```cpp
int main(int argc, const char** argv) {
  jit<argv[1]>();
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
$CXX -fjit hello_world.cpp -o hello_world
```
<!-- .element: class="fragment" data-fragment-index="2" -->

<pre><code>ls -lh hello_world</code> -> <font color="white">75M</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

##### Compiler is included in the binary and pre-compiled module of the host
<!-- .element: class="fragment" data-fragment-index="4" -->

----

### Hello World - [P1609r1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1609r3.html)

<pre><code>./hello_world "int"</code> -> <font color="lime">i</font></pre>
<!-- .element: class="fragment" data-fragment-index="1" -->

<pre><code>./hello_world "double"</code> -> <font color="lime">d</font></pre>
<!-- .element: class="fragment" data-fragment-index="2" -->

<pre><code>./hello_world "decltype([]{})"</code> -> <font color="lime">3$_0</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code>./hello_world "error"</code> -> <font color="salmon">terminate called after throwing an instance of
    'clang_compile_error'</font></pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

----

### Hello World - [P1609r1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1609r3.html)

```cpp
template<class T>
[[clang::jit]] auto jit() -> void {
  T{}(); // invokes lambda expression
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

<pre><code>./hello_world "decltype([]{
                 std::puts(\"Hello world from JIT!\");
              })"</code> -> <font color="lime">Hello world from JIT!</font></pre>
<!-- .element: class="fragment" data-fragment-index="2" -->

---

```cpp
template<auto Expr>
[[clang::jit]] auto jit() -> void {
  Expr();
}
```
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code>./hello_world "[]{ std::puts(\"Hello world from JIT!\"); }"</code> -> <font color="lime">Hello world from JIT!</font></pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

----

### Handling errors

```cpp
template<auto Expr>
[[clang::jit]] auto jit() -> void {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  try {
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
    Expr(); // throws clang_compile_error
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  } catch(const clang_compile_error& err) {
    std::cerr << err.what() << '\n';
  }
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

<pre><code>jit<"foo">()</code> -> <font color="salmon">error: 'foo' was not declared in this scope</font></pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

----

### Utilities

```cpp
template<auto Expr>
[[clang::jit]] auto compiles() -> expected<clang_compile_error> {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  try {
    jit<Expr>();
  } catch(const clang_compile_error& err) {
    return err;
  }
  return true;
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

<pre>-> <font color="lime">assert(compiles<"[]{}">())</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre>-> <font color="salmon">assert(not compiles<"[}">())</font></pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

----

### Meta

```cpp
template<auto N>
[[clang::jit]] auto make_const(auto n) -> std::string {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  return "std::integral_constant<" + std::to_string(N + n) << '\n';
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
const auto value = make_const<40>(2); // "std::integral_constant<42>"
```
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code>jit< value >()</code> -> <font color="white">std::integral_constant<42></font></pre>
<!-- .element: class="fragment" data-fragment-index="4" -->

----

### How it works? - Details

<a href="https://www.youtube.com/watch?v=6dv9vdGIaWs"><img src="images/jit.png" style="width: 75%; background:none; border:none; box-shadow:none;" /></a>

#### https://github.com/hfinkel/llvm-project-cxxjit
<!-- .element: class="fragment" -->

==============================================================================

## Examples: C++20 and beyond

----

### Mix compile-time & run-time (1)

```cpp
  template <auto... Ns>
  constexpr auto sort = [](auto... ns) {
    // combine & sort CT & RT values
    using T = std::common_type_t<decltype(Ns)..., decltype(ns)...>;
    std::vector<T> v{Ns..., ns...};
    std::sort(std::begin(v), std::end(v));

    // return comma-separated string (=> NTTP parameter pack)
    std::stringstream sorted{};
    std::copy(std::begin(v), std::end(v),
              std::make_ostream_joiner(sorted, ","));
    return sorted.str();
  };
```

Notes:
Here is a sort function that takes some of its parameters as NTTPs, and the rest
as runtime values.

We're using a `vector` here but we could also use an `array` of `T`s with
`sizeof...` on both parameter packs.

Or the runtime argument could be an `array` or `vector` of values perhaps.

The return value is a `string` that we'll use as a parameter for a JIT function.

----

### Mix compile-time & run-time (2)

```cpp
  template <auto... Ns>
  [[clang::jit]] auto verify() -> void {
    static_assert(std::array{1, 2, 3, 4, 7, 9}
        == std::array{Ns...}, "Not sorted!");
  }

  int main() {
    verify<sort<1, 9, 3>(4, 2, 7)>();
  }
```

Notes:

Here is the JIT function template. We pass in the result of `sort` i.e. the
comma-separated string of sorted values.

Note that `sort` doesn't have to be `constexpr`!

----

### Dispatch / Read–eval–print loop (REPL)

```cpp
// Handlers
struct foo { static auto on(auto event) { std::cout << "foo"; } };
struct bar { static auto on(auto event) { std::cout << "bar"; } };
```
<!-- .element: class="fragment"-->

```cpp
// Events
struct e1 {};
struct e2 {};
struct e3 {};
```
<!-- .element: class="fragment"-->

---

```cpp
// Run-time dispatch
std::unordered_map<std::string, std::string> dispatcher = {
  { "e1", "foo" },
  { "e2", "bar" }
};
```
<!-- .element: class="fragment"-->

----

### Dispatch / Read–eval–print loop (REPL)

```cpp
constexpr auto make_dispatcher(const auto& dispatcher) {
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
  return "boost::mp11::mp_list<" +
    join(dispatcher, [](const auto& e) {
      return "std::pair<" + e.first + ',' + e.second + '>';
    }, ",") +
  '>';
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
template<class TDispatcher, auto TEvent>
[[clang::jit]] auto dispatch() -> void {
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
  using dispatch_t = typename
    mp11::mp_map_find<TDispatcher, decltype(TEvent())>::second_type;

  dispatch_t::on(TEvent());
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="3" -->

----

### Dispatch / Read–eval–print loop (REPL)

<pre><code>dispatch< make_dispatcher(dispatcher), "[]{ return e1{}; }" >()</code> -> <font color="lime">foo</font></pre>
<!-- .element: class="fragment" -->

<pre><code>dispatch< make_dispatcher(dispatcher), "[]{ return e2{}; }" >()</code> -> <font color="lime">bar</font></pre>
<!-- .element: class="fragment" -->

<pre><code>dispatch< make_dispatcher(dispatcher), "[]{ return e3{}; }" >()</code> // <font color="gray">run-time compilation error</font><br/> -> <font color="salmon">error: type 'mp_map_find<
      mp_list< pair<e2, bar>, pair<e1, foo> >, decltype((lambda at <built-in>:1:10)())
      >' (aka 'void')
    cannot be used prior to '::' because it has no members</font></pre>
<!-- .element: class="fragment" -->

<pre><code>dispatch< make_dispatcher(dispatcher), "[]{ return e4{}; }" >()</code> // <font color="gray">run-time compilation error</font><br/> -> <font color="salmon">error: use of undeclared identifier 'e4'</font></pre>
<!-- .element: class="fragment" -->

----

### Save library/binary

```cpp
template<auto Expr>
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
[[clang::jit("CXXFLAGS=-O3, out=run.ir")]
auto run(bool execute) -> void {
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
  if (execute) {
    Expr();
  } // otherwise only instantiate
```
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

---

```cpp
run<"[]{ std::cout << 42; }">(true); // produces run.ir*
```
<!-- .element: class="fragment" data-fragment-index="4" -->

```cpp
run<"[]{ std::cout << 42; }">(false); // produces run.ir without
                                      // running the expression
```
<!-- .element: class="fragment" data-fragment-index="5" -->

#### * Intermediate representation (IR)
<!-- .element: class="fragment" data-fragment-index="4" -->

----

### Save library/binary

```cpp
auto run(bool) -> void;
```
<!-- .element: class="fragment" -->

```cpp
int main() {
  run(true); // templates are in IR (removed from the mangled symbol)
}
```
<!-- .element: class="fragment" -->

---

```sh
llc -filetype=obj run.ir -o run.o # IR to an object file
```
<!-- .element: class="fragment" -->

```sh
clang++ run.o main.cpp -o binary  # no -fjit required
```
<!-- .element: class="fragment" -->

<pre><code>./binary</code> -> <font color="lime">42</font></pre>
<!-- .element: class="fragment" -->

---

<pre><code>ls -lh binary</code> -> <font color="white">1.3M # compiler is not included</font></pre>
<!-- .element: class="fragment" -->

<pre><code>nm binary | grep run</code> -> <font color="white">_Z3runb</font></pre>
<!-- .element: class="fragment" -->

----

### CPP Injection / Security breach

```sql
SELECT * FROM Users WHERE Name ="John Doe" AND Pass ="myPass"
```
<!-- .element: class="fragment" -->

```sql
-- ""="" is always TRUE
SELECT * FROM Users WHERE Name ="" or ""="" AND Pass ="" or ""=""
```
<!-- .element: class="fragment" -->

##### https://www.w3schools.com/sql/sql_injection.asp
<!-- .element: class="fragment" -->

---

```cpp
int main() {
  jit<"decltype([] {
    std::cout << \""s + std::getenv("USER") + "\"; })"s>();
}
```
<!-- .element: class="fragment" -->

<pre><code>USER=John ./cpp_injection</code> -> <font color="lime">John</font></pre>
<!-- .element: class="fragment" -->

<pre><code>USER="\";std::system(\"rm -rf /\");\"" ./cpp_injection</code> // <font color="gray">decltype([] { std::cout << "";std::system("rm -rf /");""; })</font><br/> -> <font color="lime">🔓</font></pre>
<!-- .element: class="fragment"-->

==============================================================================

## Summary

----

### Pros & Cons

* #### (+) Purely C++ solution
<!-- .element: class="fragment" -->

* #### (+) Direct access to the host
<!-- .element: class="fragment" -->

* #### (+) Compile-time performance (Memoization)
<!-- .element: class="fragment" -->

* #### (+) Run-time performance (Optimizations based run-time on data/hardware)
<!-- .element: class="fragment" -->

* #### (-) Based on strings (security conernces)
<!-- .element: class="fragment" -->

* #### (-) Doesn't support compile-time injection
<!-- .element: class="fragment" -->

----

### Future?

```cpp
[[clang::jit]]           // run-time
```
<!-- .element: class="fragment" -->

```cpp
consteval [[clang::jit]] // compile-time
```
<!-- .element: class="fragment" -->

```cpp
constexpr [[clang::jit]] // compile/run-time
```
<!-- .element: class="fragment" -->

==============================================================================

---

### Let's `JIT` all the things?!
### Questions?

---

#### https://github.com/QuantlabFinancial | https://www.quantlab.com/careers


          </script>
        </section>

      </div>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Display controls in the bottom right corner
        controls: true,

        // Display a presentation progress bar
        progress: false,

        // Display the page number of the current slide
        slideNumber: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'convex', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'extensions/plugin/line-numbers/line-numbers.js' }
        ]
      });
    </script>

  </body>
</html>
