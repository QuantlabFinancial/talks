<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Just-in-Time Compilation: The Next Big Thing?</title>

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
    <link rel="stylesheet" href="extensions/plugin/line-numbers/line-numbers.css">
    <link rel="stylesheet" href="extensions/css/highlight-styles/zenburn.css">
    <link rel="stylesheet" href="extensions/css/custom.css">

    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );

      function set_address(self, remote, local) {
        if (window.location.search.match("local")) {
          self.href = local;
        } else {
          self.href = remote;
        }
      }
    </script>

    <meta name="description" content="Just-in-Time Compilation: The Next Big Thing?">
    <meta name="author" content="Ben Deane & Kris Jusiak">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$">
          <script type="text/template">

#### CppCon / 16th September 2020

---

## Just-in-Time Compilation: The Next Big Thing?

---

#### Ben Deane & Kris Jusiak - Quantlab Financial

Note:
Introductions:

[Ben] This is Kris...

[Kris] This is Ben...

==============================================================================

### Agenda

* #### Motivation & explanation
<!-- .element: class="fragment" -->

* #### Existing solutions
<!-- .element: class="fragment" -->

* #### How it works: source and compilation
<!-- .element: class="fragment" -->

* #### Simple use cases
<!-- .element: class="fragment" -->

* #### Possibilities: C++20 and beyond
<!-- .element: class="fragment" -->

Notes:

==============================================================================

## Motivations

----

### What is JITting?

Instead of Ahead-of-Time (AOT), aka "the norm":

Just-in-Time (JIT) is compilation at the point of need.

It's like the application (/library) is the compiler...

Notes:
If you've seen JF's talk this is probably familiar

----

### Why JIT-compile?

One or more of these reasons:

* AOT is not possible
* AOT is not desirable
* JIT gives perf benefits
* JIT gives productivity benefits
* JIT allows different workflows/use cases

Notes:

----

### Sometimes AOT is not possible/desirable

* If I don't *have* the AOT source, obviously I can't compile it.
* If I don't *have* the parameters that will constrain the code at runtime, I can't tailor the code to them.
* AOT might lock me into an ABI.

Notes:

If the source is provided by a client; by a colleague who is using my
library/application; by a tool that is autogenerating code, perhaps.

If I know arguments used to parameterize code, normally I could use a
template. But maybe these arguments are only available at runtime.

----

### Sometimes JIT gives performance benefits

* If I don't know where the source is going to be run, I can't AOT-compile with the best architecture flags.
* I might not be running the code on just one architecture.
* In order to get the best possible optimization, I need the best possible information about *all* the code.

Notes:

If I'm compiling for just one target, maybe I can achieve the best perf. But
many of us are not doing that. And many of us are shipping to multiple
architectures and maybe maintaining multiple binary distributions.

If we can reduce the amount of binary maintenance, that's probably good.

----

### Sometimes JIT is more productive

* I can trade AOT-compilation time (developer time) against JIT-compilation time (user time).
* With JIT, I can compile just what is needed rather than accounting for all possible use cases.

Notes:

Compilation time is something we want to minimise. JIT allows a new tradeoff.
We're trying to minimise total time: compile-time + run-time. And that is going
to depend on several things.

With JIT we can minimise that total time *over time* by choosing when we compile
things as well as how we compile them.

And by compiling just what we need we can avoid unnecessary work.

----

### JIT allows different use cases

* "OK, so I can compile code at point of need. So what?"
* It's just the tip of the iceberg, as we shall see...

Notes:

Much of the second half of the talk covers various use cases that we've thought of.

There are bound to be many more. JIT is a sea-change in development, something
like adopting version control.

==============================================================================

### Existing solutions

* #### Facebookâ€™s C++ JIT
<!-- .element: class="fragment" -->

* #### runtime-cpp
<!-- .element: class="fragment" -->

* #### Cling
<!-- .element: class="fragment" -->

* #### [[clang::jit]] <- [P1609](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1609r3.html)
<!-- .element: class="fragment" -->

* #### [...](https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus/wiki/Alternatives)
<!-- .element: class="fragment" -->

----

### Exising solutions - Dlang - https://dlang.org/articles/mixin.html

```d
template GenStruct(string Name, string M1) {
  const char[] GenStruct = "struct " ~ Name ~ "{ int " ~ M1 ~ "; }";
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```d
mixin(GenStruct!("Foo", "bar"));
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```d
struct Foo { int bar; }
```
<!-- .element: class="fragment" data-fragment-index="3" -->

----

==============================================================================

#### Hello World - [P1609](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1609r3.html)

```cpp
template <class T>
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
[[clang::jit]]
```
<!-- .element: class="fragment" data-fragment-index="2" -->

```cpp
auto jit() {
  std::cout << typeid(T).name() << '\n';
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
int main(int argc, const char** argv) {
  jit<argv[1]>();
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

<pre><code>jit<int>()</code> -> <font color="lime">d</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

```cpp
$CXX -fjit hello_world.cpp -o hello_world.out
```

```sh
ls -lh hello_world.out
# compiler is included in the binary and pre-compiled module of the host
```

<pre><code>./hello_world.out "int"</code> -> <font color="lime">i</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code>./hello_world.out "double"</code> -> <font color="lime">d</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code>./hello_world.out "error"</code> -> <font color="lime">d</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

<pre><code>./hello_world.out "decltype([]{})"</code> -> <font color="lime">$0</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

---

<pre><code>./hello_world.out "decltype([]{})"</code> -> <font color="lime">d</font></pre>
<!-- .element: class="fragment" data-fragment-index="3" -->

----

### `[[clang::jit]]` - Pros

* #### Support for types
<!-- .element: class="fragment" -->

* #### Direct access to the host
<!-- .element: class="fragment" -->

* #### compile-time performance
<!-- .element: class="fragment" -->

  * #### Memoization
<!-- .element: class="fragment" -->

* #### Run-time performance
<!-- .element: class="fragment" -->

  * #### Optimizations based on data
<!-- .element: class="fragment" -->

  * #### Supported platform
<!-- .element: class="fragment" -->

----

### `[[clang::jit]]` - Cons

* #### Based on strings - might be overused
<!-- .element: class="fragment" -->

* #### Doesn't support compile-time injection / only run-time
<!-- .element: class="fragment" -->

----

compiles
auto
return a string -> use a type

#### `Cpp` Injection - https://www.w3schools.com/sql/sql_injection.asp

```sql
SELECT * FROM Users WHERE Name ="John Doe" AND Pass ="myPass"
```

```sql
SELECT * FROM Users WHERE Name ="" or ""="" AND Pass ="" or ""=""
```
> The SQL above is valid and will return all rows from the "Users" table, since OR ""="" is always TRUE.

```cpp
```

```cpp
```




Read-Compile-Run-Loop (REPL)
save binary using IR from a function

Notes:
Note the attribute on the `jit` function. This tells the JIT compiler that this
function should be JITted.

And we pass in a string as a template parameter. The contents of that string
become the type `T` that the function is instantiated with.

==============================================================================

## Mix compile-time & run-time (1)

```cpp
  template <auto... Ns>
  constexpr auto sort = [](auto... ns) {
    // combine & sort CT & RT values
    using T = std::common_type_t<decltype(Ns)..., decltype(ns)...>;
    std::vector<T> v{Ns..., ns...};
    std::sort(std::begin(v), std::end(v));

    // return comma-separated string (=> NTTP parameter pack)
    std::stringstream sorted{};
    std::copy(std::begin(v), std::end(v),
              std::make_ostream_joiner(sorted, ","));
    return sorted.str();
  };
```

Notes:
Here is a sort function that takes some of its parameters as NTTPs, and the rest
as runtime values.

We're using a `vector` here but we could also use an `array` of `T`s with
`sizeof...` on both parameter packs.

Or the runtime argument could be an `array` or `vector` of values perhaps.

The return value is a `string` that we'll use as a parameter for a JIT function.

----

## Mix compile-time & run-time (2)

```cpp
  template <auto... Ns>
  [[clang::jit]] auto verify() -> void {
    static_assert(std::array{1, 2, 3, 4, 7, 9}
        == std::array{Ns...}, "Not sorted!");
  }

  int main() {
    verify<sort<1, 9, 3>(4, 2, 7)>();
  }
```

Notes:

Here is the JIT function template. We pass in the result of `sort` i.e. the
comma-separated string of sorted values.

Note that `sort` doesn't have to be `constexpr`!

----



==============================================================================

## C++20 and beyond

Notes:

Let's think about some more powerful use cases when we mix in features from
C++20 and beyond.

==============================================================================

## Examples

----

## Dynamic lambda expression

```cpp
template<class T>
[[clang::jit]] auto execute() -> void {
  T{}(); // invokes lambda expression
}

int main() {
  execute<"decltype([]{ std::cout << __PRETTY_FUNCTION__ << '\n'; }">();
}
```

----

## Jit compile-time error

```cpp
template<class T> [[clang::jit]] auto jit() -> void { }
constexpr auto compiles = [](auto code) {
  try {
    jit<code>();
  } catch(const clang_jit_error& e) {
    return false;
  }
  return true;
}

int main() {
  static_assert(    compiles("decltype([]{       })"));
  static_assert(not compiles("decltype([]{ error })"));
}
```

----

## Templated main / binary

```cpp
template<class T>
[[clang::jit]] auto jit_main(int argc, char** argv) -> int {
  T{}(argc, argv);
  return 0;
}

int main() {
  clang.jit.save_binary(
    "jit.out",
    &jit_main<"decltype([](int argc, char** argv){ std::cout << argc << '\n'; })">
  );
}
```

```
./jit.out 1   # prints 1
./jit.out 1 2 # prints 2
```

----

## Jit + reflection

----

## Constexpr + Jit = D lang mixins -> https://dlang.org/articles/mixin.html

----

## C++ script

```cpp
#!/bin/c++-jit
std::cout << typeid(argv[0]).name() << '\n';
```

----

## DI

```cpp
[](type t) {} // to be injected
```

----

## C++ JIT injection

----

## Dispatching

```cpp
unordered_map<int, string> mapping{}
mapping[42] = "std::cout << 42";
Generate a switch over keys and execute lambda expressions from valuesc
```

----

## Embed + JIT self injection/modification

----

## JIT works with types and or strings

```cpp
template<class T> [[clang::jit]] call() {}
call<"decltype([]{})">(); // Okay
call<decltype([]{}>();    // Also Okay, which is great for generated code as the attribute will be ignored and call still can be done
```

==============================================================================

## Summary

==============================================================================

### Let's `JIT` all the things!

---

### Questions?

---

#### Ben Deane & Kris Jusiak - Quantlab Financial
          </script>
        </section>

      </div>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Display controls in the bottom right corner
        controls: true,

        // Display a presentation progress bar
        progress: false,

        // Display the page number of the current slide
        slideNumber: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'convex', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'extensions/plugin/line-numbers/line-numbers.js' }
        ]
      });

      <!--window.addEventListener("mousedown", handleClick, false);-->
      <!--window.addEventListener("contextmenu", function(e) { e.preventDefault(); }, false);-->

      <!--function handleClick(e) {-->
        <!--if (1 >= outerHeight - innerHeight) {-->
          <!--document.querySelector( '.reveal' ).style.cursor = 'none';-->
        <!--} else {-->
          <!--document.querySelector( '.reveal' ).style.cursor = '';-->
        <!--}-->

        <!--e.preventDefault();-->
        <!--if(e.button === 0) Reveal.next();-->
        <!--if(e.button === 2) Reveal.prev();-->
      <!--}-->
    </script>

  </body>
</html>
